<template>
  <view class="page">
    <view class="head">
      <text class="h1">Game</text>
      <text class="sub">{{ turnText }}</text>
    </view>

    <view class="boardWrap">
      <view class="boardFrame" :style="frameStyle">
        <view class="boardRowWrap">
          <!-- å·¦ä¾§ 8-1 -->
          <view class="ranksCol" :style="ranksColStyle">
            <view v-for="r in rows" :key="'rank_' + r" class="rankCell" :style="rankCellStyle">
              <text class="coordText">{{ rankLabel(r) }}</text>
            </view>
          </view>

          <!-- æ£‹ç›˜ -->
          <view class="board" :style="boardStyle">
            <view v-for="r in rows" :key="'row_' + r" class="boardRow" :style="rowStyle">
              <view
                v-for="c in cols"
                :key="r + '_' + c"
                class="cell"
                :class="cellClass(r, c)"
                :style="cellStyle"
                @tap="onTapCell(r, c)"
              >
                <text class="piece">{{ pieceAt(r, c) }}</text>
              </view>
            </view>
          </view>
        </view>

        <!-- åº•éƒ¨ a-h -->
        <view class="filesRow" :style="filesRowStyle">
          <view class="filesSpacer" :style="filesSpacerStyle"></view>
          <view v-for="c in cols" :key="'file_' + c" class="fileCell" :style="fileCellStyle">
            <text class="coordText">{{ fileLabel(c) }}</text>
          </view>
        </view>
      </view>
    </view>

    <view class="panel">
      <view class="rowInfo rowFirst">
        <text class="label">å½“å‰å›åˆ</text>
        <text class="value">{{ turnText }}</text>
      </view>

      <view class="rowInfo">
        <text class="label">é€‰ä¸­</text>
        <text class="value">{{ selectedText }}</text>
      </view>

      <view class="btns">
        <view class="btn" @tap="resetBoard">
          <text class="btnText">é‡ç½®æ£‹ç›˜</text>
        </view>
      </view>
    </view>
  </view>
</template>

<script setup lang="uts">
import { ref, computed } from 'vue'

/* è¡Œåˆ— */
const rows = [0,1,2,3,4,5,6,7]
const cols = [0,1,2,3,4,5,6,7]

/* ========= âœ… å°ºå¯¸ï¼šä¿®å¤â€œæ£‹ç›˜æ˜¾ç¤ºä¸å…¨â€ =========
   æ€»å®½ = boardPx + coordPx
   æ‰€ä»¥ boardPx å¿…é¡»ç”¨ (å¯ç”¨å®½åº¦ - coordPx) æ¥ç®—
   coordPx åˆä¾èµ– cellPxï¼Œæ‰€ä»¥ç”¨ 2~3 æ¬¡è¿­ä»£æ”¶æ•›
*/
const boardPx = ref<number>(320)
const coordPx = ref<number>(22)

function clamp(n: number, minV: number, maxV: number): number {
  if (n < minV) return minV
  if (n > maxV) return maxV
  return n
}

function calcCoordFromCell(cell: number): number {
  let v = Math.floor(cell * 0.55)
  if (v < 18) v = 18
  if (v > 26) v = 26
  return v
}

function recalcSizes() {
  const info: GetSystemInfoResult = uni.getSystemInfoSync()
  const ww: number = info.windowWidth

  // é¡µé¢å·¦å³ padding å…± 36ï¼ˆpage padding 18px*2ï¼‰
  const maxTotal = ww - 36

  // åˆå§‹å‡è®¾
  let c = 22
  let b = maxTotal - c

  // è¿­ä»£ä¸¤ä¸‰æ¬¡ï¼Œè®© coordPx ä¸ cellPx ä¸€è‡´
  for (let i = 0; i < 3; i++) {
    // board çº¦æŸèŒƒå›´ + å¯¹é½ 8 çš„å€æ•°
    b = clamp(b, 240, 360)
    b = b - (b % 8)

    const cell = b / 8
    c = calcCoordFromCell(cell)

    // ä¿è¯æ€»å®½ä¸è¶…
    b = maxTotal - c
  }

  // æœ€ç»ˆå†å¯¹é½ä¸€æ¬¡
  b = clamp(b, 240, 360)
  b = b - (b % 8)
  c = calcCoordFromCell(b / 8)

  boardPx.value = b
  coordPx.value = c
}

recalcSizes()

const cellPx = computed((): number => boardPx.value / 8)

/* style å­—ç¬¦ä¸² */
const boardStyle = computed((): string => {
  const px = boardPx.value.toString() + 'px'
  return 'width:' + px + ';height:' + px + ';'
})

const rowStyle = computed((): string => {
  const w = boardPx.value.toString() + 'px'
  const h = cellPx.value.toString() + 'px'
  return 'width:' + w + ';height:' + h + ';'
})

const cellStyle = computed((): string => {
  const px = cellPx.value.toString() + 'px'
  return 'width:' + px + ';height:' + px + ';flex:0 0 ' + px + ';'
})

/* å¤–æ¡†ï¼ˆå«åæ ‡ï¼‰ */
const frameStyle = computed((): string => {
  const w = (boardPx.value + coordPx.value).toString() + 'px'
  const h = (boardPx.value + coordPx.value).toString() + 'px'
  return 'width:' + w + ';height:' + h + ';'
})

const ranksColStyle = computed((): string => {
  const w = coordPx.value.toString() + 'px'
  const h = boardPx.value.toString() + 'px'
  return 'width:' + w + ';height:' + h + ';'
})

const rankCellStyle = computed((): string => {
  const w = coordPx.value.toString() + 'px'
  const h = cellPx.value.toString() + 'px'
  return 'width:' + w + ';height:' + h + ';'
})

const filesRowStyle = computed((): string => {
  const w = (boardPx.value + coordPx.value).toString() + 'px'
  const h = coordPx.value.toString() + 'px'
  return 'width:' + w + ';height:' + h + ';'
})

const filesSpacerStyle = computed((): string => {
  const w = coordPx.value.toString() + 'px'
  const h = coordPx.value.toString() + 'px'
  return 'width:' + w + ';height:' + h + ';'
})

const fileCellStyle = computed((): string => {
  const w = cellPx.value.toString() + 'px'
  const h = coordPx.value.toString() + 'px'
  return 'width:' + w + ';height:' + h + ';'
})

function rankLabel(r: number): string { return (8 - r).toString() }
function fileLabel(c: number): string { return String.fromCharCode(97 + c) }

/* ========= å¯¹å¼ˆ ========= */
type Turn = 'white' | 'black'
const turn = ref<Turn>('white')

class Pos { r: number; c: number; constructor(r: number, c: number){ this.r=r; this.c=c } }
const selected = ref<Pos | null>(null)

/* Unicode */
const BR='â™œ', BN='â™', BB='â™', BQ='â™›', BK='â™š', BP='â™Ÿ'
const WR='â™–', WN='â™˜', WB='â™—', WQ='â™•', WK='â™”', WP='â™™'

type Board = (string | null)[][]

function createInitBoard(): Board {
  return [
    [BR, BN, BB, BQ, BK, BB, BN, BR],
    [BP, BP, BP, BP, BP, BP, BP, BP],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [null, null, null, null, null, null, null, null],
    [WP, WP, WP, WP, WP, WP, WP, WP],
    [WR, WN, WB, WQ, WK, WB, WN, WR]
  ]
}
const board = ref<Board>(createInitBoard())

function pieceAt(r:number,c:number):string{
  const p = board.value[r][c]
  return p==null?'':p
}

function isWhitePiece(p:string):boolean{ return p==WR||p==WN||p==WB||p==WQ||p==WK||p==WP }
function isBlackPiece(p:string):boolean{ return p==BR||p==BN||p==BB||p==BQ||p==BK||p==BP }
function colorOf(p:string):Turn{ return isWhitePiece(p)?'white':'black' }

/* ===== åˆæ³•èµ°å­ï¼šåŸºç¡€è§„åˆ™ + ä¸é€å°† ===== */
function inBounds(r:number,c:number):boolean{ return r>=0&&r<8&&c>=0&&c<8 }

function cloneBoard(b:Board):Board{
  const nb:Board=[]
  for(let i=0;i<8;i++){
    const nr:(string|null)[]=[]
    for(let j=0;j<8;j++) nr.push(b[i][j])
    nb.push(nr)
  }
  return nb
}

function isEmpty(b:Board,r:number,c:number):boolean{ return b[r][c]==null }
function isEnemyAt(b:Board,r:number,c:number,me:Turn):boolean{
  const p=b[r][c]; if(p==null) return false
  return (me=='white')?isBlackPiece(p):isWhitePiece(p)
}

function rayClear(b:Board,sr:number,sc:number,dr:number,dc:number):boolean{
  const dR=dr-sr, dC=dc-sc
  const stepR=dR==0?0:(dR>0?1:-1)
  const stepC=dC==0?0:(dC>0?1:-1)
  let r=sr+stepR, c=sc+stepC
  while(r!=dr || c!=dc){
    if(!isEmpty(b,r,c)) return false
    r+=stepR; c+=stepC
  }
  return true
}

function pieceType(p:string):string{
  if(p==WP||p==BP) return 'P'
  if(p==WN||p==BN) return 'N'
  if(p==WB||p==BB) return 'B'
  if(p==WR||p==BR) return 'R'
  if(p==WQ||p==BQ) return 'Q'
  return 'K'
}

function findKing(b:Board,who:Turn):Pos|null{
  const k=(who=='white')?WK:BK
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      if(b[r][c]==k) return new Pos(r,c)
    }
  }
  return null
}

function isSquareAttacked(b:Board,tr:number,tc:number,by:Turn):boolean{
  // pawn
  if(by=='white'){
    const r=tr+1
    if(inBounds(r,tc-1)&&b[r][tc-1]==WP) return true
    if(inBounds(r,tc+1)&&b[r][tc+1]==WP) return true
  }else{
    const r=tr-1
    if(inBounds(r,tc-1)&&b[r][tc-1]==BP) return true
    if(inBounds(r,tc+1)&&b[r][tc+1]==BP) return true
  }
  // knight
  const kd=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]]
  for(let i=0;i<kd.length;i++){
    const rr=tr+kd[i][0], cc=tc+kd[i][1]
    if(!inBounds(rr,cc)) continue
    const p=b[rr][cc]; if(p==null) continue
    if(by=='white'&&p==WN) return true
    if(by=='black'&&p==BN) return true
  }
  // king
  for(let rr=tr-1;rr<=tr+1;rr++){
    for(let cc=tc-1;cc<=tc+1;cc++){
      if(rr==tr&&cc==tc) continue
      if(!inBounds(rr,cc)) continue
      const p=b[rr][cc]; if(p==null) continue
      if(by=='white'&&p==WK) return true
      if(by=='black'&&p==BK) return true
    }
  }
  // rook/queen rays
  const rd=[[-1,0],[1,0],[0,-1],[0,1]]
  for(let i=0;i<rd.length;i++){
    let rr=tr+rd[i][0], cc=tc+rd[i][1]
    while(inBounds(rr,cc)){
      const p=b[rr][cc]
      if(p!=null){
        if(by=='white'&&(p==WR||p==WQ)) return true
        if(by=='black'&&(p==BR||p==BQ)) return true
        break
      }
      rr+=rd[i][0]; cc+=rd[i][1]
    }
  }
  // bishop/queen rays
  const bd=[[-1,-1],[-1,1],[1,-1],[1,1]]
  for(let i=0;i<bd.length;i++){
    let rr=tr+bd[i][0], cc=tc+bd[i][1]
    while(inBounds(rr,cc)){
      const p=b[rr][cc]
      if(p!=null){
        if(by=='white'&&(p==WB||p==WQ)) return true
        if(by=='black'&&(p==BB||p==BQ)) return true
        break
      }
      rr+=bd[i][0]; cc+=bd[i][1]
    }
  }
  return false
}

function isKingInCheck(b:Board,who:Turn):boolean{
  const k=findKing(b,who)
  if(k==null) return false
  const opp:Turn=(who=='white')?'black':'white'
  return isSquareAttacked(b,k.r,k.c,opp)
}

function canMovePieceRaw(b:Board,sr:number,sc:number,dr:number,dc:number,who:Turn):boolean{
  if(!inBounds(sr,sc)||!inBounds(dr,dc)) return false
  if(sr==dr&&sc==dc) return false
  const p=b[sr][sc]; if(p==null) return false
  if(colorOf(p)!=who) return false
  const dst=b[dr][dc]
  if(dst!=null && colorOf(dst)==who) return false

  const t=pieceType(p)
  const dR=dr-sr, dC=dc-sc
  const absR=Math.abs(dR), absC=Math.abs(dC)

  if(t=='P'){
    const dir=(who=='white')?-1:1
    const startRow=(who=='white')?6:1
    if(dC==0){
      if(dR==dir && isEmpty(b,dr,dc)) return true
      if(sr==startRow && dR==2*dir){
        const mid=sr+dir
        if(isEmpty(b,mid,sc)&&isEmpty(b,dr,dc)) return true
      }
      return false
    }
    if(absC==1 && dR==dir){
      return isEnemyAt(b,dr,dc,who)
    }
    return false
  }

  if(t=='N'){
    return (absR==2&&absC==1)||(absR==1&&absC==2)
  }

  if(t=='B'){
    if(absR!=absC) return false
    return rayClear(b,sr,sc,dr,dc)
  }

  if(t=='R'){
    if(!(dR==0||dC==0)) return false
    return rayClear(b,sr,sc,dr,dc)
  }

  if(t=='Q'){
    const ok=(absR==absC)||(dR==0||dC==0)
    if(!ok) return false
    return rayClear(b,sr,sc,dr,dc)
  }

  // K
  return absR<=1 && absC<=1
}

function isLegalMove(b:Board,sr:number,sc:number,dr:number,dc:number,who:Turn):boolean{
  if(!canMovePieceRaw(b,sr,sc,dr,dc,who)) return false
  const nb=cloneBoard(b)
  nb[dr][dc]=nb[sr][sc]
  nb[sr][sc]=null
  if(isKingInCheck(nb,who)) return false
  return true
}

/* ===== âœ… ç»“æŸåˆ¤æ–­ï¼ˆå°†æ­»/å’Œæ£‹ï¼‰ ===== */
function hasAnyLegalMove(b: Board, who: Turn): boolean {
  for (let sr = 0; sr < 8; sr++) {
    for (let sc = 0; sc < 8; sc++) {
      const p = b[sr][sc]
      if (p == null) continue
      if (colorOf(p) !== who) continue

      for (let dr = 0; dr < 8; dr++) {
        for (let dc = 0; dc < 8; dc++) {
          if (isLegalMove(b, sr, sc, dr, dc, who)) return true
        }
      }
    }
  }
  return false
}

type EndState = 'playing' | 'checkmate' | 'stalemate'

function getEndStateForSideToMove(b: Board, sideToMove: Turn): EndState {
  const hasMove = hasAnyLegalMove(b, sideToMove)
  if (hasMove) return 'playing'
  const inCheck = isKingInCheck(b, sideToMove)
  return inCheck ? 'checkmate' : 'stalemate'
}

function opposite(who: Turn): Turn { return who == 'white' ? 'black' : 'white' }

/* ===== âœ… å…µå‡å˜ ===== */
function promotionPiece(who: Turn, choice: number): string {
  // choice: 0=Q,1=R,2=B,3=N
  if (who == 'white') {
    if (choice == 1) return WR
    if (choice == 2) return WB
    if (choice == 3) return WN
    return WQ
  } else {
    if (choice == 1) return BR
    if (choice == 2) return BB
    if (choice == 3) return BN
    return BQ
  }
}

function shouldPromote(p: string, dr: number): boolean {
  if (p == WP && dr == 0) return true
  if (p == BP && dr == 7) return true
  return false
}

function askPromotion(who: Turn): Promise<number> {
  // è¿”å› choice: 0..3ï¼›å–æ¶ˆ/å¤±è´¥è¿”å› 0ï¼ˆé»˜è®¤å‡åï¼‰
  return new Promise((resolve) => {
    uni.showActionSheet({
      itemList: ['å‡å â™•/â™›', 'å‡è½¦ â™–/â™œ', 'å‡è±¡ â™—/â™', 'å‡é©¬ â™˜/â™'],
      success: (res: ShowActionSheetSuccess) => {
        const idx: number = res.tapIndex
        if (idx >= 0 && idx <= 3) resolve(idx)
        else resolve(0)
      },
      fail: () => {
        resolve(0)
      }
    })
  })
}

async function promoteIfNeeded(b: Board, dr: number, dc: number, movedPiece: string, whoMoved: Turn) {
  if (!shouldPromote(movedPiece, dr)) return
  const choice = await askPromotion(whoMoved)
  b[dr][dc] = promotionPiece(whoMoved, choice)
}

/* ===== âœ… resetBoardï¼šåªä¿ç•™ä¸€ä»½ï¼Œå¹¶ä¸”æ”¾åœ¨ onTapCell å‰é¢ ===== */
function resetBoard(){
  board.value=createInitBoard()
  selected.value=null
  turn.value='white'
}

/* ===== äº¤äº’ ===== */
async function onTapCell(r:number,c:number){
  const piece=board.value[r][c]

  if(selected.value==null){
    if(piece==null) return
    if(turn.value=='white'&&isWhitePiece(piece)) selected.value=new Pos(r,c)
    else if(turn.value=='black'&&isBlackPiece(piece)) selected.value=new Pos(r,c)
    return
  }

  const sr=selected.value.r, sc=selected.value.c
  const moving=board.value[sr][sc]
  if(moving==null){ selected.value=null; return }

  // ç‚¹åˆ°å·±æ–¹å­ï¼šæ”¹é€‰
  if(piece!=null && (
    (turn.value=='white' && isWhitePiece(piece)) ||
    (turn.value=='black' && isBlackPiece(piece))
  )){
    selected.value=new Pos(r,c)
    return
  }

  const ok=isLegalMove(board.value,sr,sc,r,c,turn.value)
  if(!ok){
    uni.showToast({ title:'éæ³•èµ°æ³•', icon:'none' })
    return
  }

  // ===== è½å­ =====
  const whoMoved: Turn = turn.value
  board.value[r][c]=moving
  board.value[sr][sc]=null
  selected.value=null

  // ===== âœ… å…µå‡å˜ï¼ˆå…ˆå‡å˜ï¼Œå†åˆ‡å›åˆ/åˆ¤ç»ˆå±€ï¼‰=====
  await promoteIfNeeded(board.value, r, c, moving, whoMoved)

  // ===== åˆ‡æ¢å›åˆ =====
  const nextTurn: Turn = opposite(whoMoved)
  turn.value = nextTurn

  // ===== âœ… ç»“æŸåˆ¤æ–­ï¼šå°†æ­» / å’Œæ£‹ =====
  const endState = getEndStateForSideToMove(board.value, nextTurn)
  if (endState != 'playing') {
    let msg = ''
    if (endState == 'checkmate') {
      // nextTurn æ— æ£‹å¯èµ°ä¸”è¢«å°†å†› => nextTurn è¾“ï¼ŒwhoMoved èµ¢
      msg = (whoMoved == 'white') ? 'ç™½æ–¹èƒœåˆ©ï¼ˆå°†æ­»ï¼‰ï¼' : 'é»‘æ–¹èƒœåˆ©ï¼ˆå°†æ­»ï¼‰ï¼'
    } else {
      msg = 'å’Œæ£‹ï¼ˆæ— åˆæ³•èµ°æ³•ï¼‰ğŸ¤'
    }

    uni.showModal({
      title: 'å¯¹å±€ç»“æŸ',
      content: msg,
      showCancel: false,
      success: () => { resetBoard() }
    })
  }
}

function cellClass(r:number,c:number):string{
  let cls=((r+c)%2==1)?'dark':'light'
  if(selected.value!=null && selected.value.r==r && selected.value.c==c){
    cls=cls+' selected'
  }
  return cls
}

const selectedText = computed(():string=>{
  if(selected.value==null) return 'æ— '
  const file=String.fromCharCode(97+selected.value.c)
  const rank=(8-selected.value.r).toString()
  return file+rank
})

const turnText = computed(():string => (turn.value=='white'?'ç™½æ–¹å›åˆ':'é»‘æ–¹å›åˆ'))

</script>

<style src="./game.css"></style>
